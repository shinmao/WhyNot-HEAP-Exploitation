## Off-By-One (heap based)  
Off by one is a very common mistake we can see from the program, and the exploitation can also used on stack, .bss, heap....and so on. Heap based off-by-one is also most common one popular in CTF. In this guide, I will not focus on how the off-by-one happen. if you are interested in it, you can take a look at my another article in following link.  
[Details of Programmer Mistake](https://rafaelchen.wordpress.com/2017/11/11/off-by-one/#more-1996)

### With heap exploitation
With off-by-one, only one bytes of overflow can cause RCE(remote code execution)!  
<img src="https://github.com/shinmao/WhyNot-HEAP-Exploitation/blob/master/Off-By-One/picture/off-by-one.png" width="607" height="332">  
With the picture, I will introduce two kind of off-by-one attack based on heap.  
#### Something we need to know first...  
In operation system based on 64bits, the memory is aligned with 16 bytes (and aligned with 8 bytes in x86). For example, if you ```malloc(0x108)``` prev_size header of next chunk will overlap with the 8 bytes in the end. Also because of this, the one-byte overflow can overwrite the size header.  

## :fire: Our Goal: Produce overlapping chunks to change the content of other chunks 

### off-by-one overwrite freed or allocated(Extend the chunk)  
Looking at chunks on the left side of the picture, we malloc three chunks, red for off-by-one vulnerability, second for overwriting, and the third one is our target chunk which we want to write into.  
#### Exploit 
When we malloc three chunks, we need to be careful that the size should be ```0x10*n+0x8``` or ```0x10*n-0x8``` with n is integer because we want to overwrite the size header. If we just ```malloc(0x10*n)```, the one-byte overflow will overwrite the prev_size header.  
```C
                --------------------------------------
                | a a a a a a a a  |  a a a a a a a a |  <----- whole of 16 bytes
                 --------------------------------------
 prev_si head > | a a a a a a a a  |         overflow |   <----- size header  
                --------------------------------------
```  
Second, we overwrite one byte of size header with ```second chunk size + third chunk size```, also be sure that inuse bit of second chunk is 1.  
In the end, if the second chunk is allocated, you need to free the second chunk first, and don't need to do nothing if the chunk is already freed. When you malloc(second_size+third_size), you can get write accress to the third chunk!

### off-by-one overwrite null byte(Shrink the chunk)  
Compared with the above one, this time we will overwrite the size with null byte. Our target is to get access to **b2** chunk. 
#### Exploit  
1. malloc 3 chunks and give a fake size in the second chunk.  
(The reason I will talk about in later  
2. free second chunk -> free first chunk  
3. malloc a A)chunk whose size isn't aligned with 16bytes  (e.g. 0x38  
read data to A and off-by-one overflow to B  
4. malloc a chunk of unsorted bin size.  
(make sure to get from unsorted bin  
**In step 4, Because getting from unsorted bin needs unlink, it will take a check on prev_size==size**  
It's why we forge size in step 1.  
5. malloc a small (b1 chunk  
6. free B) second chunk  
7. free C) third chunk.  
(Then, C chunk will check whether last chunk is freed by inuse bit  
and, use prev_size to find the last chunk header and consolidate and unlink  
8. Now, we can control the whole chunk!! (Second + Third
```C Â 
    first          second           third
  A-----------B-------------------C---------  
  |          |     |      |       |        |
  |          |     b1     b2      |        |  
  |          |     |      |       |        |  
  |          |     |      |       |        |    
  |-----------------------------------------
```  
  
**Use GDB to trace the code of exploit.c file and you can get it done!** :+1::+1:

### How about review the consolidate  
After we free the chunk which does not come from mmap()...  
Here, the **next** chunk means in consecutive memory!  
 ```
 if (next chunk is top chunk && previous chunk is freed) : 
     consolidate into top chunk...  
 elif (next chunk isn't top chunk) : 
     if (previous chunk is freed)  
          unlink the prev chunk and consolidate  
     elif (next chunk is freed or inuse) :
          unlink the free chunk and get into the unsorted bin  
 else :  
     Go away.....
 ```
 
 ### Practice  
 * [NTU-CTF-2017 shik_in_heap](https://github.com/shinmao/CTF-writeups/tree/master/NTU-CTF-2017/shik_in_the_heap)
