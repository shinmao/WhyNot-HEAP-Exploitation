## What's Unsorted bin Attack?  
Overwrite the **bk pointer** of free unsorted bin chunk, then we can control the pointer to the place we malloc again.  
  
## Review about Unsorted bin  
Before we start, how about review again the unsorted bin. When a chunk which is larger than fastbin is freed into bin, it will be put into unsorted bin first, and also be care that it isn't next to freed chunk and top chunk, or it will be consolidated. Next, how do we choose the chunk from unsorted bin list? Chunks in unsorted bin would be removed in **FIFO manner**. When user malloc() and cannot find match size in fastbin, it will start to search from unsorted bin and get **the matched-size ones** or **cut from the bigger one**!  
  
## v.s. unsafe-unlink? Â 
In fact, I am very confused about the difference between unsorted-bin-attack and unsafe-unlink at first because that they all exploit the skill of **unlink**. However, they are two different mechanism in fact, we should be care about that before we get into the detail of Unsorted bin attack!  
```C
unlink(P,BK,FD){
  FD = P->fd;
  BK = P->bk;
  FD->bk = BK;
  BK->fd = FD;  
```  
Unlink happen when we **delete(free)** a node, the free chunk in the bin will check their **BK** and **FD** whether they are also free chunk or not. If it is, they will execute unlink to consolidate together.  
  
## Get into details of Unsorted bin Attack  
```C
/* remove from unsorted list */
unsorted_chunks (av)->bk = bck;
bck->fd = unsorted_chunks (av); 
```  
Looking at the source code above. When we get the chunk from unsorted bin......  
Then I use unsorted_bin_attack.c to show how this exploitation work.  
<img src = "https://github.com/shinmao/WhyNot-HEAP-Exploitation/blob/master/Unsorted-Bin-Attack/picture/unsorted-attack.png" width="920" height = "260">  
The source code of the picture above is in the file of **unsorted_bin_attack.c**, and I seperate it to steps by steps.  
The key point of this exploitation is on the second sentence of the **remove mechanism**:```bck->fd = unsorted_chunks(av)```, and now I would like to name the key sentence as :key:.  
  
:camel: **First**, We assume that there is a vulnerability helps us overwrite the **bk pointer** (maybe heap overflow), so now the **bck** value may be the value we can control.  

:camel: **Second**, remember that the node->bk or node->fd are all catched with offset, so bck->fd is equal to the value of **bck+0x10**, so you can imagine that we always overwrite bk pointer with ```target_address-0x10```.  

:camel: **Third**, I was stuck in an awkward problem for hours XD. We can get the result from the code above and we see that the value at our target address is changed to the first chunk bk pointer, I was suspicious that it may not match the :key: ?! In fact, we all need to be care about that such sentences not mean ```value1 = value2``` here, but it should means ```address -> value```! Therefore, in :key:, we can realize that the value at the address of target will change to **unsorted__chunks(av)**, the HEAD chunk in the unsorted bin, and we have get it previously from the p->bk!  
  
<img src="https://github.com/shinmao/WhyNot-Heap-Exploitation/blob/master/Unsorted-Bin-Attack/picture/attack_flow.png" width="890" height="425">  
Thanks to the CTF-WIKI for the picture above which can help me understand in soon :smile:.  
  
## Practice
[NTU-CTF-2017 magicheap](https://github.com/shinmao/CTF-writeups/tree/master/NTU-CTF-2017/magicheap)
